package com.mct.auto_clicker.database.room.dao;

import android.util.Log;

import androidx.annotation.NonNull;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Helper class to update a list in the database.
 * <p>
 * When updating a complete list of entities in a database, you have the find which items will be added, updated or
 * removed. This class provides this information using the method [refreshUpdateValues] to parse the list, and the
 * [toBeAdded], [toBeUpdated] and [toBeRemoved] list to get the information.
 * <p>
 * E type of the items in the list to be updated.
 * K type of the primary key of the items [E].
 * defaultPrimaryKey the default value for the primary key. This is the default room value for an autogenerated
 * primary key (ex: Long = 0L).
 * primaryKeySupplier provides the item primary key.
 */
public class EntityListUpdater<E, K> {
    private final K defaultPrimaryKey;
    private final Function<E, K> primaryKeyFunc;

    public EntityListUpdater(K defaultPrimaryKey, Function<E, K> primaryKeyFunc) {
        this.defaultPrimaryKey = defaultPrimaryKey;
        this.primaryKeyFunc = primaryKeyFunc;
    }

    /**
     * The list of items to be added.
     */
    private final List<E> toBeAdded = new ArrayList<E>();
    /**
     * The list of items to be updated.
     */
    private final List<E> toBeUpdated = new ArrayList<E>();
    /**
     * The list of items to be removed.
     */
    private final List<E> toBeRemoved = new ArrayList<E>();

    public void refreshUpdateValues(@NonNull List<E> oldList, @NonNull List<E> newList) {
        toBeAdded.clear();
        toBeUpdated.clear();
        toBeRemoved.clear();
        // New items with the default primary key should be added, others should be updated.
        newList.forEach(newChild -> {
            if (primaryKeyFunc.apply(newChild) == defaultPrimaryKey) {
                toBeAdded.add(newChild);
            } else {
                toBeUpdated.add(newChild);
            }
        });

        // All items in the old list that aren't in the new one should be removed.
        toBeRemoved.addAll(oldList.stream()
                .filter(oldChild -> newList.stream().noneMatch(newChild -> primaryKeyFunc.apply(oldChild) == primaryKeyFunc.apply(newChild)))
                .collect(Collectors.toList())
        );
    }

    public List<E> getToBeAdded() {
        return toBeAdded;
    }

    public List<E> getToBeUpdated() {
        return toBeUpdated;
    }

    public List<E> getToBeRemoved() {
        return toBeRemoved;
    }
}
